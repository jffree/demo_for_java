# Base

1. `equals` 和 `==`
    1. `==`是一个比较运算符，基本数据类d型比较的是值，引用数据类型比较的是地址值。
    2. `equals()` 是一个方法，只能比较引用数据类型。重写前比较的是地址值，重写后比一般是比较对象的属性。
        1. 自反性：对于任何非空引用x，x.equals(x)应该返回true。
        2. 对称性：对于任何引用x和y，如果x.equals(y)返回true，那么y.equals(x)也应该返回true。
        3. 传递性：对于任何引用x、y和z，如果x.equals(y)返回true，y.equals(z)返回true，那么x.equals(z)也应该返回true。
        4. 一致性：如果x和y引用的对象没有发生变化，那么反复调用x.equals(y)应该返回同样的结果。
        5. 非空性：对于任意非空引用x，x.equals(null)应该返回false。

2. Java 中的引用
    1. 强引用是使用最普遍的引用。如果一个对象具有强引用，那么垃圾回收器绝不会回收它。
        1. JVM即使抛出OOM异常，也不会回收强引用所指向的对象。
    2. 软引用是除了强引用外，最强的引用类型。可以通过 `java.lang.ref.SoftReference` 使用软引用。
       一个持有软引用的对象，不会被JVM很快回收，JVM会根据当前堆的使用情况来判断何时回收。当堆使用率临近阈值时，才会去回收软引用的对象。
       软引用可以用于实现对内存敏感的高速缓存。
    3. 弱引用是一种比软引用较弱的引用类型。在系统GC时，只要发现弱引用，不管系统堆空间是否足够，都会将对象进行回收。
       由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。
       弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器标记。
    4. 虚引用是所有类型中最弱的一个。一个持有虚引用的对象和没有引用几乎是一样的，随时可能被垃圾回收器回收。
       当试图通过虚引用的get()方法取得强引用时，总是会失败。
       虚引用必须和引用队列一起使用，它的作用在于检测对象是否已经从内存中删除，跟踪垃圾回收过程。
       
3. `Comparable` 是内部比较器，而 `Comparator` 是外部比较器。
    1. 一个类本身实现了 `Comparable` 比较器，就意味着它本身支持排序；
    2. 若它本身没实现 `Comparable`，也可以通过外部比较器 `Comparator` 进行排序。
    
4. 异常：
    1. 关键字：
        * `try`     -- 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。
        * `catch`   -- 用于捕获异常。catch用来捕获try语句块中发生的异常。
        * `finally` -- finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。
        * `throw`   -- 用于抛出异常。
        * `throws`  -- 用在方法签名中，用于声明该方法可能抛出的异常。
    2. 异常分类
        * `Throwable` 是 Java 语言中所有错误或异常的超类。
        * `Exception` 及其子类是 `Throwable` 的一种形式，它指出了合理的应用程序想要捕获的条件。
        * `RuntimeException`（`Exception` 的字类） 是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。
           编译器不会检查 `RuntimeException` 异常。
           如果代码会产生 `RuntimeException` 异常，则需要通过修改代码进行避免。例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！
        * `Error` 和 `Exception` 一样，`Error` 也是 `Throwable` 的子类。它用于指示合理的应用程序不应该试图捕获的严重问题，大多数这样的错误都是异常条件。
           和 `RuntimeException` 一样，编译器也不会检查 `Error`。
    3. 使用
     1. Java将可抛出(`Throwable`)的结构分为三种类型：被检查的异常(`Checked Exception`)，运行时异常(`RuntimeException`)和错误(`Error`)。
     2. 运行时异常
     定义: `RuntimeException`及其子类都被称为运行时异常。
     特点: Java编译器不会检查它。也就是说，当程序中可能出现这类异常时，倘若既"没有通过`throws`声明抛出它"，也"没有用`try-catch`语句捕获它"，还是会编译通过。例如，除数为零时产生的`ArithmeticException`异常，数组越界时产生的IndexOutOfBoundsException异常，fail-fail机制产生的ConcurrentModificationException异常等，都属于运行时异常。
     　　虽然Java编译器不会检查运行时异常，但是我们也可以通过`throws`进行声明抛出，也可以通过`try-catch`对它进行捕获处理。
     　　如果产生运行时异常，则需要通过修改代码来进行避免。例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！
     3. 被检查的异常
     定义: `Exception` 类本身，以及 `Exception` 的子类中除了"运行时异常"之外的其它子类都属于被检查异常。
     特点: Java编译器会检查它。此类异常，要么通过throws进行声明抛出，要么通过 `try-catch` 进行捕获处理，否则不能通过编译。例如，`CloneNotSupportedException` 就属于被检查异常。当通过`clone()`接口去克隆一个对象，而该对象对应的类没有实现Cloneable接口，就会抛出CloneNotSupportedException异常。
     　　被检查异常通常都是可以恢复的。
     4. 错误
     定义: `Error` 类及其子类。
     特点: 和运行时异常一样，编译器也不会对错误进行检查。
     　　当资源不足、约束失败、或是其它程序无法继续运行的条件发生时，就产生错误。程序本身无法修复这些错误的。例如，`VirtualMachineError`就属于错误。
     　　按照Java惯例，我们是不应该是实现任何新的`Error`子类的！
     5. 对于上面的3种结构，我们在抛出异常或错误时，到底该哪一种？《Effective Java》中给出的建议是：对于可以恢复的条件使用被检查异常，对于程序错误使用运行时异常。
           
## 参考

* [Java异常简介及其架构](https://www.cnblogs.com/skywang12345/p/3544168.html)

* **《Effective Java》**

* 