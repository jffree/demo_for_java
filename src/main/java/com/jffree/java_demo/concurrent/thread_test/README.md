# 线程的介绍

1. 等待与唤醒
    1. `notify()`  -- 唤醒在此对象监视器上等待的单个线程。
    2. `notifyAll()` -- 唤醒在此对象监视器上等待的所有线程。
    3. `wait()` -- 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 `notify()` 方法或 `notifyAll()` 方法”，当前线程被唤醒(进入“就绪状态”)。
    4. `wait(long timeout)` -- 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 `notify()` 方法或 `notifyAll()` 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。
    5. `wait(long timeout, int nanos)`  -- 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 `notify()` 方法或 `notifyAll()` 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量”，当前线程被唤醒(进入“就绪状态”)。
    6. `yield()` 的作用是让步。它能让当前线程由“运行状态”进入到“就绪状态”，从而让其它具有相同优先级的等待线程获取执行权；但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是当前线程又进入到“运行状态”继续运行！
        * `wait()` 是让线程由“运行状态”进入到“等待(阻塞)状态”，而不yield()是让线程由“运行状态”进入到“就绪状态”。
        * `wait()` 是会线程释放它所持有对象的同步锁，而yield()方法不会释放锁。
    7. `sleep()` 的作用是让当前线程休眠，即当前线程会从“运行状态”进入到“休眠(阻塞)状态”。
       `sleep()` 会指定休眠时间，线程休眠的时间会大于/等于该休眠时间；在线程重新被唤醒时，它会由“阻塞状态”变成“就绪状态”，从而等待cpu的调度执行。
       `sleep()` 则不会释放锁。
    8. `join()` 的作用：当前线程等待 “某一线程” 结束之后才能继续运行。
    9. `interrupt` interrupt()并不会终止处于“运行状态”的线程，它会将线程的中断标记设为true。
       * `interrupted()` 除了返回中断标记之外，它还会清除中断标记(即将中断标记设为false)
       * `isInterrupted()` 仅仅返回中断标记。
       * 本线程中断自己是被允许的；其它线程调用本线程的interrupt()方法时，会通过checkAccess()检查权限。这有可能抛出SecurityException异常。
       * 如果本线程是处于阻塞状态：调用线程的wait(), wait(long)或wait(long, int)会让它进入等待(阻塞)状态，
         或者调用线程的join(), join(long), join(long, int), sleep(long), sleep(long, int)也会让它进入阻塞状态。若线程在阻塞状态时，调用了它的interrupt()方法，
         那么它的“中断状态”会被清除并且会收到一个InterruptedException异常。例如，线程通过wait()进入阻塞状态，此时通过interrupt()中断该线程；
         调用interrupt()会立即将线程的中断标记设为“true”，但是由于线程处于阻塞状态，所以该“中断标记”会立即被清除为“false”，同时，会产生一个InterruptedException的异常。
       * 如果线程被阻塞在一个Selector选择器中，那么通过interrupt()中断它时；线程的中断标记会被设置为true，并且它会立即从选择操作中返回。
       * 如果不属于前面所说的情况，那么通过interrupt()中断线程时，它的中断标记会被设置为“true”。
       * 中断一个“已终止的线程”不会产生任何操作。
       * `interrupted()` 和 `isInterrupted()` 都能够用于检测对象的“中断标记”。
         区别是，interrupted()除了返回中断标记之外，它还会清除中断标记(即将中断标记设为false)；而isInterrupted()仅仅返回中断标记。
    10. 线程优先级的范围是1～10，默认的优先级是5。“高优先级线程”会优先于“低优先级线程”执行。
    11. 每个线程都有一个优先级。“高优先级线程”会优先于“低优先级线程”执行。每个线程都可以被标记为一个守护进程或非守护进程。
        在一些运行的主线程中创建新的子线程时，子线程的优先级被设置为等于“创建它的主线程的优先级”，当且仅当“创建它的主线程是守护线程”时“子线程才会是守护线程”。
